#'Returns Chelsa Bioclim adresses
#'@author Helge Jentsch
#'@description This function lists the geotiff data sets of the Chelsa v1.4 data sets of the bioclim subdirectory
#'@param format.data Choose the data format. Integer and Float types are available
#'@return Vector of links to bioclim GEOTIFF data files from Chelsa Dataset
return.chelsa.bioclim.adresses <- function(format.data = c("integer","float")){
  require(RCurl)
  # url of ftp server
  url = "ftp://envidatrepo.wsl.ch/uploads/chelsa/chelsa_V1/bioclim/"
  # file names of all files in the chosen subdirectory
  filenames <- getURL(paste0(url,format.data,"/"),
                      ftp.use.epsv = F,
                      dirlistonly = T)
  # unlist the splitted output
  filenames <- unlist(strsplit(filenames, split = "\r\n"))
  # Subset the geotiff files
  filenames <- filenames[grep(filenames, pattern = ".tif")]
  # paste them all as links to the ftp server
  filenames <- paste0(url,format.data,"/",filenames)
  # return the filenames
  return(filenames)
}


#'Download Chelsa Bioclim Data with the option to clip the respective data.
#'@param filenames.download A character string of a chelsa ftp server bioclim variable
#'@param bio.factor A number of numeric vector, musn't exceed length of filenames.download
#'@param save.location string referring to the location
#'@param clip.raster.with.state logical. if raster should be clipped with a state
#'@param new.extent.shp string referring to a shapefile that has to be in a GCS WGS 1984.
#'@param clip.raster.with.state.buffer logical. should a buffer be added to the country shape
#'@param buffer.degrees numerical. In degrees width of the buffer.
#'@param clip.raster.with.extent logical. if raster should be clipped with a extent input.
#'@param new.extent.input vector with four input. Default: "xleft" = -180, "xright" = 180, "ybottom" = -90, "ytop" = 83.6236
#'@author Helge Jentsch
#'@description This function expects a vector list of ftp server of the chelsa climate data which is in
#'@return
#'@note Uses methods of the raster, stringr and svMisc packages.
#'@import raster
#'@import stringr
#'@import svMisc
download.chelsa.bioclim <- function(filenames.download = NULL, bio.factor = c(1:19), save.location = "./",
                                    clip.raster.with.state = FALSE, new.extent.shp = "./data/world/selection.shp",
                                    clip.raster.with.state.buffer = FALSE, buffer.degrees = 1,
                                    clip.raster.with.extent = FALSE,
                                    new.extent.input = c("xleft" = -180, "xright" = 180, "ybottom" = -90, "ytop" = 83.6236)){
  require(raster)
  require(stringr)
  require(svMisc)
  # Check if bio.factor length is longer than the filenames vector.
  # if yes, stop the execution.
  if(length(filenames.download)<length(bio.factor)){
    stop("bio.factor is longer than the filename.download vector. The output will contain errors!")
  }
  # create a shortnames for latter naming the raster files
  shortnames <- str_trunc(filenames.download, 19, side = "left", ellipsis = "")
  # For-Loop through all the wanted bio-factors
  for (i in bio.factor) {
    # stepi = stepi + 1
    if(!file.exists(paste0(save.location,shortnames[i]))){
      # download files from the ftp server to the save-location
      # !!! mode = "wb" very important for Windows-Machines !!!
      download.file(filenames.download[i], destfile = paste0(save.location,shortnames[i]), overwrite=T, mode = 'wb', quiet = F)
    }
    # if Argument clip.raster.with.state is TRUE
    if(clip.raster.with.state){
      # create a temporal raster object for clipping
      temp.raster <- raster(paste0(save.location,shortnames[i]))
      # new.extent <- extent(shapefile(new.extent.shp))
      # crop (clip) the temporal raster to the new extent of the shapefile
      temp.raster <- crop(temp.raster, extent(shapefile(new.extent.shp)))
      # write the cropped/clipped raster to the save location
      writeRaster(x = temp.raster,
                  filename = paste0(save.location,"clipped/clipped_",shortnames[i]),
                  overwrite=T)
    }
    if(clip.raster.with.state.buffer){
      # create a temporal raster object for clipping
      temp.raster <- raster(paste0(save.location,shortnames[i]))
      # load new extent
      new.extent.temp <- extent(buffer(shapefile(new.extent.shp), width=buffer.degrees))

      # crop (clip) the temporal raster to the new extent of the shapefile
      temp.raster <- crop(temp.raster, new.extent.temp)
      # write the cropped/clipped raster to the save location
      writeRaster(x = temp.raster,
                  filename = paste0(save.location,"buffer_clipped/buffer_clipped_",shortnames[i]),
                  overwrite=T)
    }
    # if Argument clip.raster.with.state is TRUE
    if(clip.raster.with.extent){
      # cast the vector input into a extent class
      new.extent.input <- extent(new.extent.input)
      # create a temporal raster object for clipping
      temp.raster <- raster(paste0(save.location,shortnames[i]))
      # new.extent <- extent(shapefile(new.extent.shp))
      # crop (clip) the temporal raster to the new extent of the shapefile
      temp.raster <- crop(temp.raster, new.extent.input)
      # write the cropped/clipped raster to the save location
      writeRaster(x = temp.raster,
                  filename = paste0(save.location,"extent_clipped/input_clipped_",shortnames[i]),
                  overwrite=T)
    }
    # garbage control
    gc()
  }
}

